<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Chest IMU Web — Spine Tasks</title>
<style>
  :root{
    --accent:#007aff; /* iOS system blue */
    --bg:#ffffff;
    --text:#111111;
    --sub:#555555;
    --shadow:0 10px 30px rgba(0,0,0,.08);
    --radius:18px;
    --chip:#f2f2f7;
    --border:#e5e5ea;

    /* chart colors (system-like) */
    --gx:#0a84ff;  /* blue */
    --gy:#32d74b;  /* green */
    --gz:#ff3b30;  /* red */
    --grid:#e5e5ea;
  }
  html,body{height:100%}
  body{
    margin:0;
    font-family:-apple-system, system-ui, "SF Pro Text","SF Pro Display", Segoe UI, Roboto, Arial, sans-serif;
    background:var(--bg); color:var(--text); -webkit-font-smoothing:antialiased;
  }
  /* iOS large title header */
  .header{
    position:sticky; top:0; z-index:5;
    background:linear-gradient(#f8f8f8,#fff);
    padding:20px 16px 10px; border-bottom:1px solid #eee;
  }
  .large-title{ font-size:34px; font-weight:700; letter-spacing:.2px; text-align:center; }

  /* centered card */
  .wrap{ max-width:740px; margin:18px auto; padding:0 16px; }
  .card{ background:#fff; border-radius:var(--radius); box-shadow:var(--shadow); padding:22px 18px; }

  /* layout */
  .center{text-align:center;} .vspace{margin-top:14px;}
  .hint{ color:var(--sub); font-size:14px; line-height:1.35; }
  .status{ font-weight:700; font-size:18px; margin-top:10px; }
  .pill{ padding:4px 10px; border-radius:999px; background:var(--chip); display:inline-block; font-size:13px; }
  .pill.ok{ background:#e7f3ff; color:#0a5bd8; }

  /* selector */
  .selector{
    appearance:none; font-size:22px; font-weight:600;
    padding:10px 16px; min-width:320px; max-width:100%;
    border:1px solid var(--border); border-radius:12px; background:#fff
    url("data:image/svg+xml,%3Csvg viewBox='0 0 16 10' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M2 2l6 6 6-6' stroke='%23999' stroke-width='2' fill='none' stroke-linecap='round'/%3E%3C/svg%3E")
    no-repeat right 12px center/16px 10px;
  }

  /* buttons */
  .btn{ font-size:17px; font-weight:600; padding:12px 18px; min-width:170px;
        border-radius:12px; border:1px solid transparent; cursor:pointer;
        transition:.15s transform ease, .2s background ease; display:inline-block; }
  .btn:active{ transform:scale(.98) }
  .btn-primary{ background:var(--accent); color:#fff; }
  .btn-secondary{ background:var(--chip); color:#111; border-color:var(--border); }
  .btn[disabled]{ opacity:.5; cursor:default; transform:none }
  .btns{ display:flex; gap:10px; flex-wrap:wrap; justify-content:center; }

  footer{ color:#8e8e93; font-size:12px; text-align:center; padding:16px 0 28px; }
  /* accessibility */
  [aria-live]{min-height:1.4em}

  /* chart card */
  .chart-card{
    margin-top:16px;
    background:#fff; border-radius:var(--radius); box-shadow:var(--shadow);
    padding:16px;
  }
  .chart-title{
    font-weight:700; font-size:16px; text-align:center; margin-bottom:10px;
  }
  .legend{
    display:flex; gap:12px; justify-content:center; align-items:center; flex-wrap:wrap;
    font-size:13px; color:#333; margin-bottom:8px;
  }
  .legend .dot{
    display:inline-block; width:12px; height:12px; border-radius:3px; margin-right:6px;
  }
  .axis-labels{
    display:flex; justify-content:space-between; font-size:12px; color:#666; margin-top:6px;
  }
  canvas{ width:100%; height:180px; display:block; border-radius:12px; background:#fff; }
</style>
</head>
<body>
  <div class="header">
    <div class="large-title">Spine Motion</div>
  </div>

  <div class="wrap">
    <div class="card center">
      <!-- Task -->
      <div class="vspace">
        <label for="task" class="hint" style="display:block;margin-bottom:6px;">Task</label>
        <select id="task" class="selector">
          <option>Slow Lateral Range</option>
          <option>Slow Axial Range</option>
          <option>Slow Sagittal Range</option>
          <option>Fast Lateral Continuous</option>
          <option>Fast Axial Continuous</option>
          <option>Fast Sagittal Continuous</option>
          <option>Fast Sagittal (Twist Right)</option>
          <option>Fast Sagittal (Twist Left)</option>
        </select>
      </div>

      <!-- Buttons -->
      <div class="btns vspace">
        <button id="btnStart" class="btn btn-primary">Request Permission & Start</button>
        <button id="btnStop" class="btn btn-secondary" disabled>Stop</button>
        <button id="btnSave" class="btn btn-secondary" disabled>Save CSV</button>
      </div>

      <!-- Status + hint -->
      <div id="status" class="status vspace" aria-live="polite">Idle</div>
      <div id="hint" class="hint vspace" aria-live="polite">
        Place phone at mid-chest, screen facing forward. Keep it steady.
      </div>

      <!-- Cycles (fast tasks only) -->
      <div class="vspace" id="cyclesRow" style="display:none;">
        <span class="pill ok" id="cycles">Cycles: 0/6</span>
      </div>
    </div>

    <!-- Real-time gyro chart -->
    <div class="chart-card">
      <div class="chart-title">Angular Velocity (rad/s)</div>
      <div class="legend">
        <span><span class="dot" style="background:var(--gx)"></span>gx</span>
        <span><span class="dot" style="background:var(--gy)"></span>gy</span>
        <span><span class="dot" style="background:var(--gz)"></span>gz</span>
      </div>
      <canvas id="gyroCanvas"></canvas>
      <div class="axis-labels">
        <span>Angular velocity (rad/s)</span>
        <span>Time (s) — last 10 s</span>
      </div>
    </div>

    <footer class="wrap">
      Sampling uses DeviceMotion &amp; DeviceOrientation (~60 Hz). Data stays on your device.
    </footer>
  </div>

<script>
(() => {
  // -------------------- Constants --------------------
  const TWO_PI = Math.PI * 2;
  const DEG = Math.PI / 180.0;  // deg -> rad
  const BAND   = 6  * DEG;      // near-center band (~6°)
  const THRESH = 12 * DEG;      // beyond threshold (~12°)
  const TWIST  = 15 * DEG;      // twist lock (~15°)
  const STILL_GYRO = 0.07;      // rad/s magnitude
  const STILL_WINDOW = 1000;    // ms
  const TARGET_TRIPS = 6;

  // -------------------- Session State --------------------
  let phase = 'idle'; // idle -> waitingStill -> running -> done
  let neutral = { yaw:0, pitch:0, roll:0 };
  let t0 = null;
  let stillSince = null;

  // detector runtime
  let lastOut=false, trips=0, state=0, locked=false, lockStart=null, firstSideSign=null;

  // latest readings
  let last = {
    ts: 0,
    ax: 0, ay: 0, az: 0,
    gx: 0, gy: 0, gz: 0,          // rad/s
    alpha: 0, beta: 0, gamma: 0,  // deg
    yaw: 0, pitch: 0, roll: 0     // rad
  };

  // samples buffer
  let samples = [];

  // -------------------- UI handles --------------------
  const $task    = document.getElementById('task');
  const $start   = document.getElementById('btnStart');
  const $stop    = document.getElementById('btnStop');
  const $save    = document.getElementById('btnSave');
  const $status  = document.getElementById('status');
  const $hint    = document.getElementById('hint');
  const $cycles  = document.getElementById('cycles');
  const $cyclesRow = document.getElementById('cyclesRow');

  let prevTaskValue = $task.value;

  const setStatus = (s)=> $status.textContent = s;
  const setHint   = (s)=> $hint.textContent   = s;
  const setCycles = (c)=> $cycles.textContent = `Cycles: ${c}/${TARGET_TRIPS}`;

  const isFastTask = (name) => name.includes('Fast');

  function updateCyclesVisibility(){
    const show = isFastTask($task.value);
    $cyclesRow.style.display = show ? 'block' : 'none';
  }

  function resetDetector(){
    lastOut=false; trips=0; state=0; locked=false; lockStart=null; firstSideSign=null;
    setCycles(0);
    updateCyclesVisibility();
  }

  // -------------------- Haptics --------------------
  function haptic(pattern='light'){
    // Best-effort: only works where navigator.vibrate is supported (Android Chrome).
    // iOS Safari usually ignores it (no-op).
    if (!navigator.vibrate) return;
    switch(pattern){
      case 'light':  navigator.vibrate(10); break;
      case 'medium': navigator.vibrate([12, 20, 12]); break;
      case 'heavy':  navigator.vibrate([20, 30, 20]); break;
    }
  }

  function start(){
    samples.length = 0;
    resetDetector();
    phase = 'waitingStill';
    setStatus('Waiting for stillness…');
    setHint(startHint($task.value));
    t0 = performance.now();
    stillSince = null;

    $start.disabled = true;
    $stop.disabled  = false;
    $save.disabled  = true;
    haptic('light');
  }

  function stop(){
    phase = 'idle';
    setStatus('Idle');
    $start.disabled = false;
    $stop.disabled  = true;
    $save.disabled  = samples.length === 0;
    updateCyclesVisibility();
  }

  function finish(){
    phase = 'done';
    setStatus('Done');
    setHint('Finished. Tap “Save CSV”.');
    $save.disabled = false;
    $stop.disabled = true;
    $start.disabled = false;
    haptic('medium');
  }

  // -------------------- Permission flow --------------------
  async function requestAndStart(){
    try {
      // iOS Safari requires user gesture + explicit permission
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const r1 = await DeviceMotionEvent.requestPermission();
        if (r1 !== 'granted') {
          alert('Motion permission denied. Enable “Motion & Orientation Access” in iOS Settings → Safari.');
          return;
        }
      }
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const r2 = await DeviceOrientationEvent.requestPermission();
        if (r2 !== 'granted') {
          alert('Orientation permission denied. Enable “Motion & Orientation Access” in iOS Settings → Safari.');
          return;
        }
      }
      start();
    } catch (e) {
      console.error(e);
      alert('Permission error: ' + e.message);
    }
  }

  // -------------------- Sensors --------------------
  window.addEventListener('devicemotion', (e) => {
    const now = performance.now();
    const a = e.accelerationIncludingGravity || e.acceleration;
    if (a){ last.ax = a.x || 0; last.ay = a.y || 0; last.az = a.z || 0; }
    if (e.rotationRate){
      last.gz = (e.rotationRate.alpha || 0) * DEG;  // -> rad/s (around Z)
      last.gx = (e.rotationRate.beta  || 0) * DEG;  // -> rad/s (around X)
      last.gy = (e.rotationRate.gamma || 0) * DEG;  // -> rad/s (around Y)
    }
    last.ts = now;
    step(now);
  });

  window.addEventListener('deviceorientation', (e) => {
    last.alpha = e.alpha ?? 0;
    last.beta  = e.beta  ?? 0;
    last.gamma = e.gamma ?? 0;
    // Approx mapping: yaw≈alpha(z)、pitch≈beta(x)、roll≈gamma(y)
    last.yaw   = (last.alpha || 0) * DEG;
    last.pitch = (last.beta  || 0) * DEG;
    last.roll  = (last.gamma || 0) * DEG;
  });

  // -------------------- Logic --------------------
  const isStill = ()=> Math.hypot(last.gx,last.gy,last.gz) < STILL_GYRO;

  function relAngles(){
    return {
      yaw:   wrap(last.yaw   - neutral.yaw),
      pitch: wrap(last.pitch - neutral.pitch),
      roll:  wrap(last.roll  - neutral.roll),
    };
  }
  function wrap(x){ while(x>Math.PI) x-=TWO_PI; while(x<-Math.PI) x+=TWO_PI; return x; }

  function step(now){
    if (phase === 'waitingStill'){
      if (isStill()){
        if (!stillSince) stillSince = now;
        if (now - stillSince >= STILL_WINDOW){
          neutral = { yaw:last.yaw, pitch:last.pitch, roll:last.roll };
          phase = 'running';
          setStatus('Recording…');
          setHint(runningHint($task.value));
          t0 = now;
          haptic('light');
        }
      } else {
        stillSince = null;
      }
      return;
    }

    if (phase !== 'running') return;

    const t = (now - t0) / 1000.0;
    const rel = relAngles();

    // record one sample
    samples.push({
      t,
      yaw: rel.yaw, pitch: rel.pitch, roll: rel.roll,
      ax: last.ax, ay: last.ay, az: last.az,
      gx: last.gx, gy: last.gy, gz: last.gz,
      alpha: last.alpha, beta: last.beta, gamma: last.gamma
    });

    // detector
    let finished = false;
    const task = $task.value;

    if (task === 'Slow Lateral Range') {
      finished = slowSequenceDone(rel.roll);
    } else if (task === 'Slow Axial Range') {
      finished = slowSequenceDone(rel.yaw);
    } else if (task === 'Slow Sagittal Range') {
      finished = slowSagittalDone(rel.pitch);
    } else if (task === 'Fast Lateral Continuous') {
      const r = cycle(rel.roll); finished = r.done; if (r.trips !== tripsShown){ setCycles(r.trips); haptic('light'); tripsShown=r.trips; }
    } else if (task === 'Fast Axial Continuous') {
      const r = cycle(rel.yaw);  finished = r.done; if (r.trips !== tripsShown){ setCycles(r.trips); haptic('light'); tripsShown=r.trips; }
    } else if (task === 'Fast Sagittal Continuous') {
      const r = cycle(rel.pitch); finished = r.done; if (r.trips !== tripsShown){ setCycles(r.trips); haptic('light'); tripsShown=r.trips; }
    } else if (task === 'Fast Sagittal (Twist Right)') {
      const r = twistThenCycles(rel.yaw, rel.pitch, +1);
      finished = r.done;
      if (r.locked && !lockAnnounced){ haptic('medium'); lockAnnounced = true; }
      if (r.trips !== tripsShown){ setCycles(r.trips); haptic('light'); tripsShown=r.trips; }
      setHint(r.locked ? 'Locked right: fast crunch ×6' : 'Twist RIGHT ≥15° & hold 1s');
    } else if (task === 'Fast Sagittal (Twist Left)') {
      const r = twistThenCycles(rel.yaw, rel.pitch, -1);
      finished = r.done;
      if (r.locked && !lockAnnounced){ haptic('medium'); lockAnnounced = true; }
      if (r.trips !== tripsShown){ setCycles(r.trips); haptic('light'); tripsShown=r.trips; }
      setHint(r.locked ? 'Locked left: fast crunch ×6' : 'Twist LEFT ≥15° & hold 1s');
    }

    if (finished){
      finish();
      lockAnnounced = false;
      tripsShown = TARGET_TRIPS;
      haptic('heavy');
    }
  }

  // state for haptic gating
  let lockAnnounced = false;
  let tripsShown = 0;

  // ---- detectors ----
  function slowSequenceDone(x){
    // any side → center → other side → center
    switch (state){
      case 0:
        if (Math.abs(x) > THRESH){ firstSideSign = x>0 ? +1 : -1; state = 1; }
        break;
      case 1:
        if (Math.abs(x) < BAND){ state = 2; }
        break;
      case 2:
        if (firstSideSign && ((firstSideSign>0 && x < -THRESH) || (firstSideSign<0 && x > THRESH))){ state = 3; }
        break;
      case 3:
        if (Math.abs(x) < BAND){ return true; }
        break;
    }
    return false;
  }
  function slowSagittalDone(p){
    switch (state){
      case 0: if (p > THRESH){ state = 1; } break;
      case 1: if (Math.abs(p) < BAND){ return true; }
    }
    return false;
  }
  function cycle(x){
    if (!lastOut){
      if (Math.abs(x) > THRESH) lastOut = true;
    } else {
      if (Math.abs(x) < BAND){ lastOut = false; trips += 1; }
    }
    return { trips, done: trips >= TARGET_TRIPS };
  }
  function twistThenCycles(yaw, pitch, dir){
    if (!locked){
      const ok = dir>0 ? (yaw > TWIST) : (yaw < -TWIST);
      if (ok){
        if (!lockStart) lockStart = performance.now();
        if (performance.now() - lockStart >= 1000){
          locked = true; lastOut = false; trips = 0;
        }
      } else lockStart = null;
      return { locked:false, trips, done:false };
    } else {
      const r = cycle(pitch);
      return { locked:true, trips:r.trips, done:r.done };
    }
  }

  // -------------------- Save / Share CSV --------------------
  async function saveCSV(){
    if (!samples.length) return;
    // header with units
    let s = 't(s),yaw(rad),pitch(rad),roll(rad),ax(m/s^2),ay(m/s^2),az(m/s^2),gx(rad/s),gy(rad/s),gz(rad/s),alpha(deg),beta(deg),gamma(deg)\n';
    for (const v of samples){
      s += `${v.t.toFixed(6)},${v.yaw},${v.pitch},${v.roll},${v.ax},${v.ay},${v.az},${v.gx},${v.gy},${v.gz},${v.alpha},${v.beta},${v.gamma}\n`;
    }
    const filename = `ChestIMU_${Date.now()}.csv`;
    const blob = new Blob([s], {type:'text/csv'});
    const file = new File([blob], filename, {type:'text/csv'});

    // Prefer native share (AirDrop etc.)
    if (navigator.canShare && navigator.canShare({ files:[file] }) && navigator.share){
      try{
        await navigator.share({ files:[file], title:'Chest IMU CSV', text:'Spine motion session data' });
        return;
      }catch(err){ console.warn('Share error or canceled:', err); }
    }
    // Fallback: download
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    URL.revokeObjectURL(url); a.remove();
  }

  // -------------------- Hints --------------------
  function startHint(task){
    switch (task){
      case 'Slow Lateral Range': return 'Stand still (1s). Then: side → center → other side → center.';
      case 'Slow Axial Range'  : return 'Stand still (1s). Then: twist side → center → other side → center.';
      case 'Slow Sagittal Range':return 'Stand still (1s). Then: crunch forward → back to center.';
      case 'Fast Lateral Continuous' : return 'Stand still (1s). Then: fast lateral ×6.';
      case 'Fast Axial Continuous'   : return 'Stand still (1s). Then: fast axial twist ×6.';
      case 'Fast Sagittal Continuous': return 'Stand still (1s). Then: fast crunch ×6.';
      case 'Fast Sagittal (Twist Right)': return 'Stand still (1s). Then: twist RIGHT ≥15° & hold 1s → fast crunch ×6.';
      case 'Fast Sagittal (Twist Left)' : return 'Stand still (1s). Then: twist LEFT ≥15° & hold 1s → fast crunch ×6.';
    }
    return '';
  }
  function runningHint(task){
    switch (task){
      case 'Slow Lateral Range'     : return 'Go: side → center → other side → center.';
      case 'Slow Axial Range'       : return 'Go: side twist → center → other side → center.';
      case 'Slow Sagittal Range'    : return 'Go: crunch forward → back to center.';
      case 'Fast Lateral Continuous': return 'Go fast: lateral ×6.';
      case 'Fast Axial Continuous'  : return 'Go fast: axial twist ×6.';
      case 'Fast Sagittal Continuous':return 'Go fast: crunch ×6.';
      case 'Fast Sagittal (Twist Right)': return 'Twist RIGHT & hold 1s to lock, then fast crunch ×6.';
      case 'Fast Sagittal (Twist Left)' : return 'Twist LEFT & hold 1s to lock, then fast crunch ×6.';
    }
    return '';
  }

  // -------------------- Bind UI --------------------
  $task.addEventListener('change', () => {
    // If running, confirm to stop
    if (phase === 'running'){
      const ok = confirm('Switching task will stop current recording. Continue?');
      if (!ok){
        // revert selection
        $task.value = prevTaskValue;
        return;
      }
      // stop current recording first
      stop();
    }
    prevTaskValue = $task.value;

    // For idle/done states: reset detector and allow immediate start
    resetDetector();
    setStatus('Idle');
    setHint(startHint($task.value));
    $start.disabled = false;   // allow Start after changing task
    $stop.disabled  = true;
    $save.disabled  = samples.length === 0;
    haptic('light');
  });

  document.getElementById('btnStart').addEventListener('click', requestAndStart);
  document.getElementById('btnStop' ).addEventListener('click', () => { stop(); haptic('light'); });
  document.getElementById('btnSave' ).addEventListener('click', saveCSV);

  // -------------------- Real-time Chart --------------------
  const canvas = document.getElementById('gyroCanvas');
  const ctx = canvas.getContext('2d');
  // Handle high-DPI
  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const cssW = canvas.clientWidth;
    const cssH = canvas.clientHeight;
    canvas.width  = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  // buffer: last 10 seconds @ ~60Hz -> ~600 samples
  const WINDOW_SEC = 10;
  const MAX_S = 600;
  const buf = [];
  function pushSample(ts, gx, gy, gz){
    buf.push({ts, gx, gy, gz});
    while (buf.length > MAX_S) buf.shift();
  }

  // auto-scale with smoothing
  let yRange = 2.0;    // initial ±2 rad/s
  function updateScale(){
    if (buf.length < 2) return;
    let maxAbs = 0;
    for (const p of buf){ maxAbs = Math.max(maxAbs, Math.abs(p.gx), Math.abs(p.gy), Math.abs(p.gz)); }
    const target = Math.max(1.0, Math.min(20.0, maxAbs * 1.3)); // clamp to [1, 20]
    // smooth lerp
    yRange = yRange * 0.9 + target * 0.1;
  }

  function draw(){
    const w = canvas.clientWidth, h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // grid
    ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
    ctx.lineWidth = 1;
    ctx.beginPath();
    // horizontal lines (5)
    for (let i=0;i<=4;i++){
      const y = (i/4)*h;
      ctx.moveTo(0,y); ctx.lineTo(w,y);
    }
    ctx.stroke();

    // axes labels are in HTML below canvas; here just draw lines
    // compute time window
    const now = performance.now();
    const tMin = now - WINDOW_SEC*1000;
    // compress to [0,w]
    function xOf(ts){ return ( (ts - tMin) / (WINDOW_SEC*1000) ) * w; }
    function yOf(val){ return h/2 - (val / yRange) * (h*0.45); } // keep margin

    // lines
    function drawLine(color, key){
      ctx.strokeStyle = color; ctx.lineWidth = 2;
      ctx.beginPath();
      let started = false;
      for (const p of buf){
        if (p.ts < tMin) continue;
        const x = xOf(p.ts);
        const y = yOf(p[key]);
        if (!started){ ctx.moveTo(x,y); started = true; }
        else { ctx.lineTo(x,y); }
      }
      ctx.stroke();
    }

    drawLine(getComputedStyle(document.documentElement).getPropertyValue('--gx').trim(), 'gx');
    drawLine(getComputedStyle(document.documentElement).getPropertyValue('--gy').trim(), 'gy');
    drawLine(getComputedStyle(document.documentElement).getPropertyValue('--gz').trim(), 'gz');

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);

  // feed chart on motion
  const origDevMotionHandler = (e) => {};
  // we already set the main devicemotion handler above; here hook pushing logic into it:
  const origStep = step;
  step = function(now){
    // push to chart buffer
    pushSample(now, last.gx, last.gy, last.gz);
    updateScale();
    // continue original logic
    origStep(now);
  }

  // initialize
  updateCyclesVisibility();
})();
</script>
</body>
</html>
